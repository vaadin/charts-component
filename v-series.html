<!--
@license
Vaadin Charts

Copyright (C) 2015 Vaadin Ltd

This program is available under Commercial Vaadin Add-On License 3.0 (CVALv3).

See the file LICENSE.md distributed with this software for more information about licensing.

See <a href="https://vaadin.com/license/cval-3">the website</a> for the complete license.
-->
<link rel="import" href="../polymer/polymer.html">

<script>
    ChartSeries = Polymer({
        is: "v-series",
        properties: {

            /**
             * Series id
             */
            id: {
                type: String
            },

            /**
             * Is drilldown series
             */
            drilldown: {
                type: Boolean,
                value: false
            },

            /**
             * Series name
             */
            name: {
                type: String
            },

            /**
             * Series type.
             */
            type: {
                type: String
            },

            /**
             * Series yAxis ID.
             */
            yAxis: {
                type: String
            },

            /**
             * Series size.
             */
            size: {
                type: String
            },

            /**
             * Series innerSize.
             */
            innerSize: {
                type: String
            },

            /**
             * Series dashStyle.
             */
            dashStyle: {
                type: String
            },

            color: String,

            negativeColor: String,

            /* ----------- internal ----------- */

            /**
             * Initial chart configuration before initial rendering.
             **/
            _seriesConf: {
                type: Object,
                value: function () {
                    return {};
                }
            }

        },

        _ignoredNodes: ["#text", "#comment"],

        /**
         * Transform the given string to camel-case
         *
         * @param {string} str
         **/
        _toCamelCase: function (str) {
            var out = "";
            str.split("-").forEach(function (word, idx) {
                var add = word.toLowerCase();
                out += (idx === 0 ? add : add[0].toUpperCase() + add.slice(1));
            });
            return out;
        },

        _parentChart: function () {
            var parent = Polymer.dom(this.root).parentNode;
            while (parent._addSeries === undefined) {
                parent = parent.parentNode;
            }
            return parent;
        },

        /**
         * Load the configuration from the element attributes and the light-DOM elements.
         **/
        _loadConfiguration: function () {
            this._loadPropertiesFromAttributes();
            var element = Polymer.dom(this);
            this._cleanNode(element);
            for (var n = 0; n < element.childNodes.length; n++) {
                var node = element.childNodes[n];
                var name = node.nodeName.toLowerCase();
                if (this._ignoredNodes.indexOf(name) === -1) {
                    var camelName = this._toCamelCase(name);
                    var value = node.textContent;
                    if (camelName === 'data') {
                        if (this._hasPointNodes(node)) {
                            value = [];
                            for (var n = 0; n < node.childNodes.length; n++) {
                                value.push(this._parsePoint(node.childNodes[n]));
                            }
                        } else {
                            value = '[' + value + ']';
                        }
                    }
                    this._setProperty(camelName, value);
                }
            }
        },

        /**
         * Creates a point object from a point node.
         **/
        _parsePoint: function (pointNode) {
            var result = {};
            for (var n = 0; n < pointNode.childNodes.length; n++) {
                var node = pointNode.childNodes[n];
                var camelName = this._toCamelCase(node.nodeName.toLowerCase());
                if ('date' === camelName) {
                    if (result['x'] === undefined) {
                        var parsedDate = this._parseDate(node.textContent);
                        if (parsedDate !== undefined) {
                            result['x'] = parsedDate;
                        } else {
                            console.log('Unable to parse date: ' + node.textContent);
                        }
                    } else {
                        console.log('x value is already defined for this point, \'' +
                                node.textContent + '\' couldn\'t be set');
                    }
                } else if (result[camelName] === undefined) {
                    try {
                        result[camelName] = JSON.parse(node.textContent);
                    } catch (e) {
                        result[camelName] = node.textContent;
                    }
                } else {
                    console.log(camelName + ' value is already defined for this point, \'' +
                            node.textContent + '\' couldn\'t be set');
                }
            }
            return result;
        },

        _parseDate: function (dateString) {
            if (this._isValidDate(dateString)) {
                return Date.parse(dateString);
            }
        },

        _isValidDate: function (dateString) {
            try {
                var dateValue = new Date(dateString);
                //If dateValue is invalid getTime is NaN
                return (dateValue.toISOString().indexOf(dateString) === 0 ) &&
                        Object.prototype.toString.call(dateValue) === "[object Date]" && !isNaN(dateValue.getTime());
            } catch (e) {

            }

            return false;
        },

        /**
         * Checks if nodes has child nodes that correspond to points.
         **/
        _hasPointNodes: function (node) {
            return node.childNodes.length > 0 && 'point' === node.childNodes[0].nodeName.toLowerCase();
        },

        /**
         * Removes all empty text and comment nodes.
         **/
        _cleanNode: function (node) {
            for (var n = 0; n < node.childNodes.length; n++) {
                var child = node.childNodes[n];
                if (child.nodeType === 8 || (child.nodeType === 3 && !/\S/.test(child.nodeValue))) {
                    node.removeChild(child);
                    n--;
                } else if (child.nodeType === 1) {
                    this._cleanNode(child);
                }
            }
        },

        /**
         * Load the configuration from the element attributes.
         **/
        _loadPropertiesFromAttributes: function () {
            for (var property in this.properties) {
                if (this.properties.hasOwnProperty(property) && property.indexOf('_') !== 0) {
                    this._setProperty(property, this[property]);
                }
            }
        },

        /**
         * Set single property in series configuration.
         * @param {string} name
         * @param {object} value to be set
         **/
        _setProperty: function (name, value) {
            var parsedValue = this._parseProperty(value);

            //value might be undefined because all properties are iterated in _loadPropertiesFromAttributes
            //in such case it shouldn't be set to keep _seriesConf minimal
            if (undefined !== parsedValue) {
                if (undefined === this._seriesConf[name]) {
                    this._seriesConf[name] = parsedValue;
                } else if (name === 'data') {
                    Array.prototype.push.apply( this._seriesConf[name], parsedValue );
                }
            }
        },

        /**
         * Parse property value into most appropriate type.
         * @param {object} value to be set
         **/
        _parseProperty: function (value) {
            var result;
            if (undefined !== value) {
                try {
                    //try to parse as simple JSON
                    result = JSON.parse(value);
                } catch (e) {
                    try {
                        //try to parse as JSON with js code for instance Date.UTC(...)
                        result = eval(value);
                    } catch (e) {
                        result = value;
                    }
                }
            }
            return result;
        },

        ready: function () {
            this._loadConfiguration();
            if (this.drilldown) {
                this._parentChart()._addDrilldownSeries(this._seriesConf);
            } else {
                this._parentChart()._addSeries(this._seriesConf);
            }
        }

    });
</script>
