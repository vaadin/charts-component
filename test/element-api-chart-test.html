<!doctype html>

<head>
  <meta charset="UTF-8">
  <title>vaadin-chart tests</title>
  <script src="../../web-component-tester/browser.js"></script>
  <link rel="import" href="../vaadin-chart.html">
</head>

<body>
  <test-fixture id="default">
    <template>
      <vaadin-chart title="My title"
                    subtitle="My subtitle"
                    categories="[2010,2011,2012,2013]"
                    additional-options='{"legend": {"title": {"text": "Legend title"}}, "exporting": {"enabled": true}, "credits": {"enabled": true, "text": "Vaadin Ltd"}, "title": {"text": "Additional title"}}'>
        <vaadin-chart-series values="[1,2,3,4]"></vaadin-chart-series>
      </vaadin-chart>
    </template>
  </test-fixture>
  <test-fixture id="tooltip">
    <template>
      <vaadin-chart additional-options='{"tooltip": {"pointFormat": "custom"}}'>
        <vaadin-chart-series values="[1,2,3,4]"></vaadin-chart-series>
      </vaadin-chart>
    </template>
  </test-fixture>
  <test-fixture id="category">
    <template>
      <vaadin-chart categories="[10,20,30,40,50]" category-min="1" category-max="2">
        <vaadin-chart-series values="[1,2,3,4,5]"></vaadin-chart-series>
      </vaadin-chart>
    </template>
  </test-fixture>
  <test-fixture id="column">
    <template>
      <vaadin-chart type="column">
        <vaadin-chart-series values="[1,2,8,18]"></vaadin-chart-series>
      </vaadin-chart>
    </template>
  </test-fixture>
  <test-fixture id="nodata">
    <template>
      <vaadin-chart></vaadin-chart>
      <vaadin-chart empty-text="Empty Vaadin Chart"></vaadin-chart>
      <vaadin-chart empty-text="Empty Vaadin Chart">
        <vaadin-chart-series values="[1,2,3]"></vaadin-chart-series>
        <vaadin-chart-series values="[4,5,6]"></vaadin-chart-series>
        <vaadin-chart-series values="[]"></vaadin-chart-series>
      </vaadin-chart>
    </template>
  </test-fixture>
  <test-fixture id="polar">
    <template>
      <vaadin-chart polar>
        <vaadin-chart-series values="[0,1,2,3]"></vaadin-chart-series>
      </vaadin-chart>
    </template>
  </test-fixture>

  <script>
    describe('High-level API', function() {
      var chart, chartContainer;

      beforeEach(done => {
        chart = fixture('default');
        chartContainer = chart.$.chart;
        Polymer.flush();
        setTimeout(() => {
          done();
        }, 100);
      });

      it('should be defined', () => {
        expect(chart.constructor.is).to.be.equal(chart.localName);
      });

      it('should have custom title', () => {
        expect(chartContainer.querySelector('.highcharts-title > tspan').textContent).to.be.equal('My title');
      });

      it('should have custom subtitle', () => {
        expect(chartContainer.querySelector('.highcharts-subtitle > tspan').textContent).to.be.equal('My subtitle');
      });

      it('should have additional-options', () => {
        // Exporting dropdown menu
        expect(chartContainer.querySelector('.highcharts-contextbutton')).to.not.be.null;
      });

      it('additional-options should overwrite conflicting base config properties', () => {
        expect(chartContainer.querySelector('.highcharts-credits').textContent).to.be.equal('Vaadin Ltd');
      });

      it('additional-options should not overwrite top-level element properties', () => {
        expect(chartContainer.querySelector('.highcharts-title > tspan').textContent).to.be.equal('My title');
      });

      it('should react to additionalOptions object change', done => {
        chart.additionalOptions = {title: {text: 'Updated title'}};

        setTimeout(() => {
          expect(chartContainer.querySelector('.highcharts-title > tspan').textContent).to.be.equal('Updated title');
          done();
        }, 100);
      });

      it('should react to additionalOptions subproperty change', done => {
        chart.set('additionalOptions.title.text', 'Reindeer statistics');

        setTimeout(() => {
          expect(chartContainer.querySelector('.highcharts-title > tspan').textContent).to.be.equal('Reindeer statistics');
          done();
        }, 150);
      });

      it('should have categories set', done => {
        setTimeout(() => {
          const textNodes = chartContainer.querySelectorAll('.highcharts-xaxis-labels > text');
          const text = Array.from(textNodes).map(node => node.textContent);
          expect(text).to.be.deep.equal(['2010', '2011', '2012', '2013']);
          done();
        }, 50);
      });

      it('should react to categories change', done => {
        chart.setAttribute('categories', '["Jan", "Fev", "Mar", "Abr"]');
        setTimeout(() => {
          const textNodes = chartContainer.querySelectorAll('.highcharts-xaxis-labels > text');
          const text = Array.from(textNodes).map(node => node.textContent);
          expect(text).to.be.deep.equal(['Jan', 'Fev', 'Mar', 'Abr']);
          done();
        }, 50);
      });

      it('should hide legend', done => {
        expect(chartContainer.querySelector('.highcharts-legend')).to.not.be.null;
        chart.setAttribute('no-legend', true);
        setTimeout(() => {
          expect(chartContainer.querySelector('.highcharts-legend')).to.be.null;
          done();
        }, 50);
      });

      it('should apply legend config via additional-options', done => {
        chart.removeAttribute('no-legend');
        setTimeout(() => {
          const legendTitle = chartContainer.querySelector('.highcharts-legend-title > text').textContent;
          expect(legendTitle).to.be.equal('Legend title');
          done();
        }, 50);
      });

      it('should not have tooltips by default', function(done) {
        setTimeout(function() {
          expect(chart.configuration.tooltip.options.enabled).to.be.false;
          done();
        }, 100);
      });

      it('should have tooltips when enabled', function(done) {
        chart.tooltip = true;
        setTimeout(function() {
          expect(chart.configuration.tooltip.options.enabled).to.be.true;
          done();
        }, 100);
      });

      it('should have tooltips when tooltip is configured in additional options', function(done) {
        chart = fixture('tooltip');
        setTimeout(function() {
          expect(chart.configuration.tooltip.options.enabled).to.be.true;
          done();
        }, 150);
      });

      it('should have category minimum set to first category by default', (done) => {
        setTimeout(() => {
          const [xAxis] = chart.configuration.xAxis;
          expect(xAxis.min).to.be.equal(0);
          done();
        }, 30);
      });

      it('should be able to set category minimum', (done) => {
        chart = fixture('category');
        setTimeout(() => {
          const [xAxis] = chart.configuration.xAxis;
          expect(xAxis.min).to.be.equal(1);
          done();
        }, 150);
      });

      it('should change category minimum value', done => {
        const newCategoryMin = 2;
        function extremesListener(event) {
          expect(event.detail.originalEvent.min).to.be.equal(newCategoryMin);
          chart.removeEventListener('xaxes-extremes-set', extremesListener);
          done();
        }
        chart.addEventListener('xaxes-extremes-set', extremesListener);
        chart.setAttribute('category-min', newCategoryMin);
      });

      it('should be able to set category maximum', (done) => {
        chart = fixture('category');
        setTimeout(() => {
          const [xAxis] = chart.configuration.xAxis;
          expect(xAxis.max).to.be.equal(2);
          done();
        }, 150);
      });

      it('should change category maximum value', done => {
        const newCategoryMax = 5;
        function extremesListener(event) {
          expect(event.detail.originalEvent.max).to.be.equal(newCategoryMax);
          chart.removeEventListener('xaxes-extremes-set', extremesListener);
          done();
        }
        chart.addEventListener('xaxes-extremes-set', extremesListener);
        chart.setAttribute('category-max', newCategoryMax);
      });

      it('should react to chart3d change', function(done) {
        chart = fixture('column');
        setTimeout(function() {
          expect(chart.configuration.frame3d).to.be.undefined;
          chart.chart3d = true;
          setTimeout(function() {
            expect(chart.configuration.frame3d).not.to.be.undefined;
            done();
          }, 150);
        }, 100);
      });

      it('should display no message for empty chart by default', done => {
        chart = fixture('nodata')[0];
        setTimeout(() => {
          const actual = chart.$.chart.querySelector('.highcharts-no-data > text').textContent.trim();
          expect(actual).to.be.empty;
          done();
        }, 100);
      });

      it('should show a the configured empty-text message for empty chart', done => {
        chart = fixture('nodata')[1];
        setTimeout(() => {
          const expected = 'Empty Vaadin Chart';
          const actual = chart.$.chart.querySelector('.highcharts-no-data > text > tspan').textContent;
          expect(expected).to.be.equal(actual);
          done();
        }, 100);
      });

      it('should react to empty-text changes on empty charts', done => {
        chart = fixture('nodata')[0];
        setTimeout(() => {
          const actual = chart.$.chart.querySelector('.highcharts-no-data > text').textContent.trim();
          expect(actual).to.be.empty;

          const newEmptyText = 'A real chart';
          chart.emptyText = newEmptyText;
          setTimeout(() => {
            const actual = chart.$.chart.querySelector('.highcharts-no-data > text > tspan').textContent;
            expect(newEmptyText).to.be.equal(actual);

            done();
          }, 100);
        }, 100);
      });

      it('should display empty-text when all series are removed form existing charts', done => {
        chart = fixture('nodata')[2];
        const newEmptyText = 'A real chart';
        chart.emptyText = newEmptyText;

        [...chart.childNodes]
          .filter(e => e.tagName === 'VAADIN-CHART-SERIES')
          .forEach(e => chart.removeChild(e));

        setTimeout(() => {
          const actual = chart.$.chart.querySelector('.highcharts-no-data > text > tspan').textContent;
          expect(newEmptyText).to.be.equal(actual);

          done();
        }, 100);
      });

      it('should display empty-text when all data-containing series are removed from existing charts', done => {
        chart = fixture('nodata')[2];
        const newEmptyText = 'A real chart';
        chart.emptyText = newEmptyText;

        [...chart.childNodes]
          .filter(e => e.tagName === 'VAADIN-CHART-SERIES')
          .splice(0, 2)
          .forEach(e => chart.removeChild(e));

        setTimeout(() => {
          const actual = chart.$.chart.querySelector('.highcharts-no-data > text > tspan').textContent;
          expect(newEmptyText).to.be.equal(actual);

          done();
        }, 100);
      });

      it('should be able to set polar', (done) => {
        const chart = fixture('polar');
        Polymer.RenderStatus.beforeNextRender(this, () => {
          const {polar} = chart.configuration.options.chart;
          expect(polar).to.be.true;
          done();
        });
      });

      it('should be able to modify polar', (done) => {
        const chart = fixture('polar');
        Polymer.RenderStatus.beforeNextRender(this, () => {
          chart.polar = false;
          const {polar} = chart.configuration.options.chart;
          expect(polar).to.not.be.true;
          done();
        });
      });
    });
  </script>
</body>
