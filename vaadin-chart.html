<!--
@license
Vaadin Charts
Copyright (C) 2015 Vaadin Ltd
This program is available under Commercial Vaadin Add-On License 3.0 (CVALv3).
See the file LICENSE.md distributed with this software for more information about licensing.
See <a href="https://vaadin.com/license/cval-3">the website</a> for the complete license.
-->

<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../polymer/lib/utils/flattened-nodes-observer.html">
<link rel="import" href="../polymer/lib/utils/render-status.html">
<link rel="import" href="../vaadin-themable-mixin/vaadin-themable-mixin.html">
<link rel="import" href="../vaadin-license-checker/vaadin-license-checker.html">
<link rel="import" href="../vaadin-element-mixin/vaadin-element-mixin.html">

<link rel="import" href="vaadin-chart-default-theme.html">

<script src="../highcharts/js/highstock.js"></script>
<!-- For some chart types, an error is raised if accessibility is added after highcharts-3d module -->
<script src="../highcharts/js/modules/accessibility.js"></script>
<script src="../highcharts/js/highcharts-more.js"></script>
<script src="../highcharts/js/highcharts-3d.js"></script>
<script src="../highcharts/js/modules/data.js"></script>
<script src="../highcharts/js/modules/drilldown.js"></script>
<script src="../highcharts/js/modules/exporting.js"></script>
<script src="../highcharts/js/modules/funnel.js"></script>
<script src="../highcharts/js/modules/heatmap.js"></script>
<script src="../highcharts/js/modules/solid-gauge.js"></script>
<script src="../highcharts/js/modules/treemap.js"></script>
<script src="./chart-temporary-display.js"></script>

<link rel="import" href="vaadin-chart-series.html">

<dom-module id="vaadin-chart">
  <template>
    <style>
      :host {
        display: block;
        width: 100%;
        overflow: hidden;
      }

      :host([hidden]) {
        display: none !important;
      }
    </style>
    <div id="chart"></div>
    <slot id="slot"></slot>
  </template>

  <script>
    if (!Polymer.Element) {
      throw new Error(`Unexpected Polymer version ${Polymer.version} is used, expected v2.0.0 or later.`);
    }

    {

      /**
       * `<vaadin-chart>` is a Polymer 2 element for creating high quality charts.
       *
       * ### Quick Start
       *
       * 1. Create a Polymer application using [Polymer CLI](https://www.polymer-project.org/2.0/docs/tools/polymer-cli)
       * ```
       * mkdir my-app
       * cd my-app
       * polymer init
       * select `polymer-2-application`
       * ```
       * 1. Install Vaadin Charts
       * ```
       * bower install --save vaadin-charts
       * ```
       * 1. Import `<vaadin-chart>` to your app
       * Edit the file `src/my-app/my-app.html` and add the following snipped before the `<dom-module>` tag
       * ```html
       * <link rel="import" href="../../bower_components/vaadin-charts/vaadin-chart.html">
       * ```
       * 1. Add your first `<vaadin-chart>`
       * Also in `my-app.html` add the following snippet before the `</template>` closing tag
       * ```html
       * <vaadin-chart></vaadin-chart>
       * ```
       * 1. Run your app with:
       * ```
       * polymer serve --open
       * ```
       * Congratulations! You have your first Vaadin Chart setup.
       *
       * ### Basic use
       *
       * Now that we covered the basic steps to create an empty chart, let us show how you can configure it.
       *
       * There are two ways of configuring your `<vaadin-chart>` element: **JS API** and **JSON API**.
       * Note that you can make use of both APIs in your element.
       *
       * #### Configuring your chart using JS API
       *
       * Using as a base the project created with in Quick Start
       *
       * Do the following changes in `my-app.html`
       *
       * 1. Set and id for the `<vaadin-chart>` in the template
       * ```html
       *     <vaadin-chart id="mychart"></vaadin-chart>
       * ```
       * 1. Add a function that uses `configuration` property (JS Api) to set chart title, categories and data
       * ```
       * initChartWithJSApi() {
       *     Polymer.RenderStatus.beforeNextRender(this, () => {
       *        const configuration = this.$.mychart.configuration;
       *        configuration.setTitle({ text: 'The chart title' });
       *        // By default there is one x axis, it is referenced by configuration.xAxis[0].
       *        configuration.xAxis[0].setCategories(['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']);
       *        configuration.addSeries({
       *            type: 'column',
       *            data: [29.9, 71.5, 106.4, 129.2, 144.0, 176.0, 135.6, 148.5, 216.4, 194.1, 95.6, 54.4]
       *        });
       *     });
       * }
       * ```
       * 1. Call that function from connectedCallback (when the element is added to a document)
       * ```
       * connectedCallback() {
       *     super.connectedCallback();
       *     this.initChartWithJSApi();
       * }
       * ```
       * 1. And finally run your app with:
       * ```
       * polymer serve --open
       * ```
       *
       *
       * #### Configuring your chart using JS JSON API
       *
       * JS JSON API is a simple alternative to the JS API.
       *
       * Using as a base the project created with in Quick Start
       *
       * Do the following changes in `my-app.html`
       *
       * 1. Set and id for the `<vaadin-chart>` in the template
       * ```html
       *     <vaadin-chart id="mychart"></vaadin-chart>
       * ```
       * 1. Add a function that uses `update` method (JS JSON Api) to set chart title, categories and data
       * ```
       * initChartWithJSJSONApi() {
       *     this.$.mychart.update({
       *       title: {
       *         text: 'The chart title'
       *       },
       *       subtitle: {
       *         text: 'Subtitle'
       *       },
       *       xAxis: {
       *         categories: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
       *       },
       *       series: [{
       *         type: 'column',
       *         data: [29.9, 71.5, 106.4, 129.2, 144.0, 176.0, 135.6, 148.5, 216.4, 194.1, 95.6, 54.4]
       *       }]
       *     });
       * }
       * ```
       * 1. Call that function from connectedCallback (when the element is added to a document)
       * ```
       * connectedCallback() {
       *     super.connectedCallback();
       *     this.initChartWithJSJSONApi();
       * }
       * ```
       * 1. And finally run your app with:
       * ```
       * polymer serve --open
       * ```
       *
       * It should be noted that chart style customization cannot be done via the JS or JSON API.
       * Styling properties in the JSON configuration will be ignored. The following section discusses chart styling.
       *
       *
       * ### CSS Styling
       * Chart appearance is primarily controlled by CSS style rules.
       * A comprehensive list of the supported style classes can be found at
       * https://www.highcharts.com/docs/chart-design-and-style/style-by-css
       *
       *
       * ### Steps for styling a chart
       *
       * 1. Create a theme file (for example `shared-styles.html`). The theme's dom-module must declare `theme-for=vaadin-chart`.
       * 2. Import `vaadin-chart-default-theme.html` and declare `include="vaadin-chart-default-theme"`
       * on the theme module's style tag to customize Chart's default theme. If there are multiple theme
       * modules *only one* of them should declare this `include`.
       * 3. Specify the desired CSS rules in the theme file.
       * 4. If multiple charts are present, each one can be specifically targeted using the host selector e.g `:host(.my-chart-class)`.
       * 5. Import the theme file.
       *
       *
       * ### Example: Two Charts with a Red Title but only one with a Blue Subtitle
       *
       * ```
       * <link rel="import" href="shared-styles.html">
       * ...
       * <vaadin-chart title="Red Title" subtitle="Not Styled">
       *   <vaadin-chart-series values="[19,12,9,24,5]"></vaadin-chart-series>
       * </vaadin-chart>
       *
       * <vaadin-chart class="blue-subtitle" title="Red Title" subtitle="Blue Subtitle">
       *   <vaadin-chart-series values="[19,12,9,24,5]"></vaadin-chart-series>
       * </vaadin-chart>
       * ```
       *
       * shared-styles.html
       *
       * ```
       * <link rel="import" href="../bower_components/vaadin-charts/vaadin-chart-default-theme.html">
       *
       * <dom-module id="css-style-example" theme-for="vaadin-chart">
       *    <template>
       *      <style include="vaadin-chart-default-theme">
       *        .highcharts-title {
       *          fill: red;
       *          font-size: xx-large;
       *        }
       *
       *        :host(.blue-subtitle) .highcharts-subtitle {
       *          fill: blue;
       *        }
       *      </style>
       *    </template>
       * </dom-module>
       * ```
       *
       * ### Setting colors
       *
       * Although charts can be styled as described above, there is a simpler way for setting colors.
       * Colors can be set using CSS custom properties `--vaadin-charts-color-{n}` (where `n` goes from `0 - 9`).
       *
       * For example `--vaadin-charts-color-0` sets the color of the first series on a chart.
       *
       * ### Validating your License
       * After one day using Vaadin Charts in a development environment you will see a pop-up that asks you
       * to validate your license by signing in to vaadin.com.
       *
       * @memberof Vaadin
       * @demo demo/index.html
       */
      class ChartElement extends Vaadin.ElementMixin(Vaadin.ThemableMixin(Polymer.Element)) {
        static get is() {
          return 'vaadin-chart';
        }

        static get version() {
          return '6.0.1';
        }

        static get properties() {
          return {
            /**
             * Configuration object that exposes the JS Api to configure the chart.
             *
             * Most important methods are:
             * - `addSeries (Object options, [Boolean redraw], [Mixed animation])`
             * - `addAxis (Object options, [Boolean isX], [Boolean redraw], [Mixed animation])`
             * - `setTitle (Object title, object subtitle, Boolean redraw)`
             *
             * Most important properties are:
             * - `configuration.series`: An array of the chart's series. Detailed API for Series object is
             *     available in [API Site](http://api.highcharts.com/class-reference/Highcharts.Series)
             * - `configuration.xAxis`: An array of the chart's x axes. Detailed API for Axis object is
             *     available in [API Site](http://api.highcharts.com/class-reference/Highcharts.Axis)
             * - `configuration.yAxis`: An array of the chart's y axes. Detailed API for Axis object is
             *     available in [API Site](http://api.highcharts.com/class-reference/Highcharts.Axis)
             * - `configuration.title`: The chart title.
             *
             * For detailed documentation of available API check the [API site](http://api.highcharts.com/class-reference/classes.list)
             * @readonly
             * @public
             * @type {Object}
             */
            'configuration': Object,

            /**
             * Specifies whether the chart is a normal chart or a timeline chart.
             */
            'timeline': {
              type: Boolean,
              reflectToAttribute: true
            },

            /**
             * Represents the title of the chart.
             */
            'title': {
              type: String,
              observer: '__updateTitle',
              reflectToAttribute: true
            },

            /**
             * Represents the subtitle of the chart.
             */
            'subtitle': {
              type: String,
              observer: '__updateSubtitle',
              reflectToAttribute: true
            }
          };
        }

        constructor() {
          super();

          /**
           * List of properties that will always be copied from the chart element to the container div
           **/
          this._copyStyleProperties = ['flex', '-webkit-flex', '-ms-flex'];

          this._baseConfig = {
            credits: {
              enabled: false
            },
            // Workaround for highcharts#7398 to make updating tooltip works
            tooltip: {

            },
            exporting: {
              enabled: false
            },
            title: {
              text: null
            },
            xAxis: {

            },
            yAxis: {

            }
          };

          this.__mutationCallback = this.__mutationCallback.bind(this);
        }

        /** @private */
        connectedCallback() {
          super.connectedCallback();
          this.__updateStyles();
          this.__addChildObserver();
          Polymer.RenderStatus.beforeNextRender(this, () => {
            // Detect if the chart had already been initialized. This might happen in
            // environments where the chart is lazily attached (e.g Grid).
            if (this.configuration) {
              this.__reflow();
              return;
            }

            const options = Object.assign({}, this.options, this._jsonConfigurationBuffer);
            this._jsonConfigurationBuffer = null;
            this.__initChart(options);
            const config = {attributes: true, characterData: true};
            this.__mutationObserver = new MutationObserver(this.__mutationCallback);
            this.__mutationObserver.observe(this, config);
          });
        }

        get options() {
          const options = Object.assign({}, this._baseConfig);

          if (this.title) {
            options.title = {
              text: this.title
            };
          }

          if (this.subtitle) {
            options.subtitle = {
              text: this.subtitle
            };
          }

          return options;
        }

        /**
         *  Name of the chart events to add to the configuration and its corresponding event for the chart element
         **/
        get __chartEventNames() {
          return {

            /**
             *
             * @event chart-add-series  Fired when a new series is added
             * @param {Object} detail.originalEvent object with details about the event sent
             * @param {Object} chart Chart object where the event was sent from
             */
            addSeries: 'chart-add-series',
            /**
             *
             * @event chart-after-print  Fired after a chart is printed
             * @param {Object} detail.originalEvent object with details about the event sent
             * @param {Object} chart Chart object where the event was sent from
             */
            afterPrint: 'chart-after-print',
            /**
             *
             * @event chart-before-print  Fired before a chart is printed
             * @param {Object} detail.originalEvent object with details about the event sent
             * @param {Object} chart Chart object where the event was sent from
             */
            beforePrint: 'chart-before-print',
            /**
             *
             * @event chart-click  Fired when clicking on the plot background
             * @param {Object} detail.originalEvent object with details about the event sent
             * @param {Object} chart Chart object where the event was sent from
             */
            click: 'chart-click',
            /**
             *
             * @event chart-drilldown  Fired when drilldown point is clicked
             * @param {Object} detail.originalEvent object with details about the event sent
             * @param {Object} chart Chart object where the event was sent from
             */
            drilldown: 'chart-drilldown',
            /**
             *
             * @event chart-drillup  Fired when drilling up from a drilldown series
             * @param {Object} detail.originalEvent object with details about the event sent
             * @param {Object} chart Chart object where the event was sent from
             */
            drillup: 'chart-drillup',
            /**
             *
             * @event chart-drillupall  Fired after all the series  has been drilled up
             *                          if chart has multiple drilldown series
             * @param {Object} detail.originalEvent object with details about the event sent
             * @param {Object} chart Chart object where the event was sent from
             */
            drillupall: 'chart-drillupall',
            /**
             *
             * @event chart-load  Fired when the chart is finished loading
             * @param {Object} detail.originalEvent object with details about the event sent
             * @param {Object} chart Chart object where the event was sent from
             */
            load: 'chart-load',
            /**
             *
             * @event chart-redraw  Fired when the chart is redraw. Can be called after a `Chart.configuration.redraw()`
             *                      or after an axis, series or point is modified with the `redraw` option set to `true`
             * @param {Object} detail.originalEvent object with details about the event sent
             * @param {Object} chart Chart object where the event was sent from
             */
            redraw: 'chart-redraw',
            /**
             *
             * @event chart-selection  Fired when an area of the chart has been selected
             * @param {Object} detail.originalEvent object with details about the event sent
             * @param {Object} chart Chart object where the event was sent from
             */
            selection: 'chart-selection'
          };
        }

        /**
         *  Name of the series events to add to the configuration and its corresponding event for the chart element
         **/
        get __seriesEventNames() {
          return {
            /**
             *
             * @event series-after-animate  Fired when the series has finished its initial animation
             * @param {Object} detail.originalEvent object with details about the event sent
             * @param {Object} series Series object where the event was sent from
             */
            afterAnimate: 'series-after-animate',
            /**
             *
             * @event series-checkbox-click  Fired when the checkbox next to the series' name in the legend is clicked
             * @param {Object} detail.originalEvent object with details about the event sent
             * @param {Object} series Series object where the event was sent from
             */
            checkboxClick: 'series-checkbox-click',
            /**
             *
             * @event series-click  Fired when the series is clicked
             * @param {Object} detail.originalEvent object with details about the event sent
             * @param {Object} series Series object where the event was sent from
             */
            click: 'series-click',
            /**
             *
             * @event series-hide  Fired when the series is hidden after chart generation time
             * @param {Object} detail.originalEvent object with details about the event sent
             * @param {Object} series Series object where the event was sent from
             */
            hide: 'series-hide',
            /**
             *
             * @event series-legend-item-click  Fired when the legend item belonging to the series is clicked
             * @param {Object} detail.originalEvent object with details about the event sent
             * @param {Object} series Series object where the event was sent from
             */
            legendItemClick: 'series-legend-item-click',
            /**
             *
             * @event series-mouse-out  Fired when the mouses leave the graph
             * @param {Object} detail.originalEvent object with details about the event sent
             * @param {Object} series Series object where the event was sent from
             */
            mouseOut: 'series-mouse-out',
            /**
             *
             * @event series-mouse-over  Fired when the mouse enters the graph
             * @param {Object} detail.originalEvent object with details about the event sent
             * @param {Object} series Series object where the event was sent from
             */
            mouseOver: 'series-mouse-over',
            /**
             *
             * @event series-show  Fired when the series is show after chart generation time
             * @param {Object} detail.originalEvent object with details about the event sent
             * @param {Object} series Series object where the event was sent from
             */
            show: 'series-show'
          };
        }

        /**
         *  Name of the point events to add to the configuration and its corresponding event for the chart element
         **/
        get __pointEventNames() {
          return {
            /**
             *
             * @event point-click  Fired when the point is clicked
             * @param {Object} detail.originalEvent object with details about the event sent
             * @param {Object} point Point object where the event was sent from
             */
            click: 'point-click',
            /**
             *
             * @event point-legend-item-click  Fired when the legend item belonging to the point is clicked
             * @param {Object} detail.originalEvent object with details about the event sent
             * @param {Object} point Point object where the event was sent from
             */
            legendItemClick: 'point-legend-item-click',
            /**
             *
             * @event point-mouse-out  Fired when the mouse leaves the area close to the point
             * @param {Object} detail.originalEvent object with details about the event sent
             * @param {Object} point Point object where the event was sent from
             */
            mouseOut: 'point-mouse-out',
            /**
             *
             * @event point-mouse-over  Fired when the mouse enters the area close to the point
             * @param {Object} detail.originalEvent object with details about the event sent
             * @param {Object} point Point object where the event was sent from
             */
            mouseOver: 'point-mouse-over',
            /**
             *
             * @event point-remove  Fired when the point is removed from the series
             * @param {Object} detail.originalEvent object with details about the event sent
             * @param {Object} point Point object where the event was sent from
             */
            remove: 'point-remove',
            /**
             *
             * @event point-select  Fired when the point is selected etheir programmatically or by clicking on the point
             * @param {Object} detail.originalEvent object with details about the event sent
             * @param {Object} point Point object where the event was sent from
             */
            select: 'point-select',
            /**
             *
             * @event point-unselect  Fired when the point is unselected etheir programmatically or by clicking on the point
             * @param {Object} detail.originalEvent object with details about the event sent
             * @param {Object} point Point object where the event was sent from
             */
            unselect: 'point-unselect',
            /**
             *
             * @event point-update  Fired when the point is updated programmatically through `.update()` method
             * @param {Object} detail.originalEvent object with details about the event sent
             * @param {Object} point Point object where the event was sent from
             */
            update: 'point-update'
          };
        }

        get __xAxesEventNames() {
          return {
            /**
             *
             * @event xaxes-extremes-set  Fired when when the minimum and maximum is set for the x axis
             * @param {Object} detail.originalEvent object with details about the event sent
             * @param {Object} axis Point object where the event was sent from
             */
            afterSetExtremes: 'xaxes-extremes-set',
          };
        }

        get __yAxesEventNames() {
          return {
            /**
             *
             * @event yaxes-extremes-set  Fired when when the minimum and maximum is set for the y axis
             * @param {Object} detail.originalEvent object with details about the event sent
             * @param {Object} axis Point object where the event was sent from
             */
            afterSetExtremes: 'yaxes-extremes-set',
          };
        }

        __reflow() {
          if (!this.configuration) {
            return;
          }
          Polymer.RenderStatus.beforeNextRender(this, () => {
            this.configuration.reflow();
          });
        }

        __mutationCallback() {
          const {height: componentHeight} = this.getBoundingClientRect();
          const {chartHeight} = this.configuration;

          if (componentHeight !== chartHeight) {
            this.__reflow();
          }
        }

        __addChildObserver() {
          Polymer.RenderStatus.beforeNextRender(this, () => {
            this._childObserver = new Polymer.FlattenedNodesObserver(this.$.slot, (info) => {
              this.__addSeries(info.addedNodes.filter(this.__filterSeriesNodes));
              this.__removeSeries(info.removedNodes.filter(this.__filterSeriesNodes));
            });
          });
        }

        __filterSeriesNodes(node) {
          return node.nodeType === Node.ELEMENT_NODE && node instanceof Vaadin.ChartSeriesElement;
        }

        __addSeries(series) {
          if (this.__isSeriesEmpty(series)) {
            return;
          }
          const seriesNodes = Array.from(this.childNodes).filter(this.__filterSeriesNodes);

          for (let i = 0, len = series.length; i < len; i++) {
            const seriesElement = series[i];

            const idxOnChildList = seriesNodes.indexOf(seriesElement);
            const seriesConfiguration = this.__updateOrAddSeriesInstance(seriesElement.options, idxOnChildList);

            seriesElement.setSeries(seriesConfiguration);
          }
        }

        __removeSeries(seriesNodes) {
          if (this.__isSeriesEmpty(seriesNodes)) {
            return;
          }
          seriesNodes.forEach(series => {
            if (series instanceof Vaadin.ChartSeriesElement) {
              series._series.remove();
            }
          });
        }

        __isSeriesEmpty(series) {
          return series === null || series.length === 0;
        }

        __initChart(options) {
          this.__initEventsListeners(options);
          // Workaround for https://github.com/highcharts/highcharts/issues/7523
          this.__ensureObjectPath(options, 'drilldown.activeDataLabelStyle');
          if (this.timeline) {
            this.configuration = Highcharts.stockChart(this.$.chart, options);
          } else {
            this.configuration = Highcharts.chart(this.$.chart, options);
          }
        }

        /** @private */
        disconnectedCallback() {
          super.disconnectedCallback();
          this.__mutationObserver && this.__mutationObserver.disconnect();
          this._childObserver && this._childObserver.disconnect();
        }

        /**
         * Update the chart configuration.
         * This JSON API provides a simple single-argument alternative to the configuration property.
         *
         * Styling properties specified in this configuration will be ignored. To learn about chart styling
         * please see the CSS Styling section above.
         *
         * @param {Object} jsonConfiguration Object chart configuration. Most important properties are:
         *
         * - chart `Object` with options regarding the chart area and plot area as well as general chart options.
         *    Detailed API for chart object is available in [API Site](http://api.highcharts.com/highcharts/chart)
         * - credits `Object` with options regarding the chart area and plot area as well as general chart options.
         *    Detailed API for credits object is available in [API Site](http://api.highcharts.com/highcharts/credits)
         * - labels `Object[]` with HTML labels that can be positioned anywhere in the chart area
         *    Detailed API for labels object is available in [API Site](http://api.highcharts.com/highcharts/labels)
         * - plotOptions `Object` wrapper for config objects for each series type.
         *    Detailed API for plotOptions object is available in [API Site](http://api.highcharts.com/highcharts/plotOptions)
         * - series `Object[]` the actual series to append to the chart.
         *    Detailed API for series object is available in [API Site](http://api.highcharts.com/highcharts/series)
         * - subtitle `Object` the chart's subtitle.
         *    Detailed API for subtitle object is available in [API Site](http://api.highcharts.com/highcharts/subtitle)
         * - title `Object` the chart's main title.
         *    Detailed API for title object is available in [API Site](http://api.highcharts.com/highcharts/title)
         * - tooltip `Object` Options for the tooltip that appears when the user hovers over a series or point.
         *    Detailed API for tooltip object is available in [API Site](http://api.highcharts.com/highcharts/tooltip)
         * - xAxis `Object[]` The X axis or category axis. Normally this is the horizontal axis.
         *    Detailed API for xAxis object is available in [API Site](http://api.highcharts.com/highcharts/xAxis)
         * - yAxis `Object[]` The Y axis or value axis. Normally this is the vertical axis.
         *    Detailed API for yAxis object is available in [API Site](http://api.highcharts.com/highcharts/yAxis)
         * - zAxis `Object[]` The Z axis or depth axis for 3D plots.
         *    Detailed API for zAxis object is available in [API Site](http://api.highcharts.com/highcharts/zAxis)
         *
         * @param {Boolean} resetConfiguration Optional boolean that should be set to true if no other chart configuration was set before or
         *    if existing configuration should be discarded.
         */
        update(jsonConfiguration, resetConfiguration) {
          if (resetConfiguration || !this._jsonConfigurationBuffer) {
            this._jsonConfigurationBuffer = {};
          }
          const configCopy = this.__deepMerge({}, jsonConfiguration);
          this.__inflateFunctions(configCopy);
          this._jsonConfigurationBuffer = this.__makeConfigurationBuffer(this._jsonConfigurationBuffer, configCopy);

          Polymer.RenderStatus.beforeNextRender(this, () => {
            if (!this.configuration || !this._jsonConfigurationBuffer) {
              return;
            }

            if (resetConfiguration) {
              const initialOptions = Object.assign({}, this.options, this._jsonConfigurationBuffer);

              this.__initChart(initialOptions);

              this._jsonConfigurationBuffer = null;
              return;
            }

            this.configuration.update(this._jsonConfigurationBuffer);
            if (this._jsonConfigurationBuffer.credits) {
              this.__updateOrAddCredits(this._jsonConfigurationBuffer.credits);
            }
            if (this._jsonConfigurationBuffer.xAxis) {
              this.__updateOrAddAxes(this._jsonConfigurationBuffer.xAxis, true);
            }
            if (this._jsonConfigurationBuffer.yAxis) {
              this.__updateOrAddAxes(this._jsonConfigurationBuffer.yAxis, false);
            }
            if (this._jsonConfigurationBuffer.series) {
              this.__updateOrAddSeries(this._jsonConfigurationBuffer.series);
            }
            this._jsonConfigurationBuffer = null;
          });
        }

        __makeConfigurationBuffer(target, source) {
          const _source = Highcharts.merge(source);
          const _target = Highcharts.merge(target);

          this.__mergeConfigurationArray(_target, _source, 'series');
          this.__mergeConfigurationArray(_target, _source, 'xAxis');
          this.__mergeConfigurationArray(_target, _source, 'yAxis');

          return Highcharts.merge(_target, _source);
        }

        __mergeConfigurationArray(target, configuration, entry) {
          if (!configuration || !configuration[entry] || !Array.isArray(configuration[entry])) {
            return;
          }

          if (!target[entry]) {
            target[entry] = Array.from(configuration[entry]);
            return;
          }

          const maxLength = Math.max(target[entry].length, configuration[entry].length);
          for (let i = 0; i < maxLength; i++) {
            target[entry][i] = Highcharts.merge(target[entry][i], configuration[entry][i]);
          }
          delete configuration[entry];
        }

        __inflateFunctions(jsonConfiguration) {
          for (var attr in jsonConfiguration) {
            if (jsonConfiguration.hasOwnProperty(attr)) {
              const targetProperty = jsonConfiguration[attr];
              if (attr.indexOf('_fn_') === 0 && (typeof targetProperty === 'string' || targetProperty instanceof String)) {
                try {
                  jsonConfiguration[attr.substr(4)] = eval('(' + targetProperty + ')');
                } catch (e) {
                  jsonConfiguration[attr.substr(4)] = eval('(function(){' + targetProperty + '})');
                }
                delete jsonConfiguration[attr];
              } else if (targetProperty instanceof Object) {
                this.__inflateFunctions(targetProperty);
              }
            }
          }
        }

        __initEventsListeners(configuration) {
          this.__initChartEventsListeners(configuration);
          this.__initSeriesEventsListeners(configuration);
          this.__initPointsEventsListeners(configuration);
          this.__initAxisEventsListeners(configuration, true);
          this.__initAxisEventsListeners(configuration, false);
        }

        __initChartEventsListeners(configuration) {
          this.__createEventListeners(this.__chartEventNames, configuration, 'chart.events', 'chart');
        }

        __initSeriesEventsListeners(configuration) {
          this.__createEventListeners(this.__seriesEventNames, configuration, 'plotOptions.series.events', 'series');
        }

        __initPointsEventsListeners(configuration) {
          this.__createEventListeners(this.__pointEventNames, configuration, 'plotOptions.series.point.events', 'point');
        }

        __initAxisEventsListeners(configuration, isXAxis) {
          let eventNames, axes;

          if (isXAxis) {
            eventNames = this.__xAxesEventNames;
            axes = configuration.xAxis;
          } else {
            eventNames = this.__yAxesEventNames;
            axes = configuration.yAxis;
          }

          if (Array.isArray(axes)) {
            axes.forEach(axis => this.__createEventListeners(eventNames, axis, 'events', 'axis'));
          } else {
            this.__createEventListeners(eventNames, axes, 'events', 'axis');
          }
        }

        __createEventListeners(eventList, configuration, pathToAdd, eventType) {
          const self = this;
          const eventObject = this.__ensureObjectPath(configuration, pathToAdd);

          for (let keys = Object.keys(eventList), i = 0; i < keys.length; i++) {
            const key = keys[i];
            if (!eventObject[key]) {
              var chart = this;
              eventObject[key] = function(event) {
                const customEvent = {
                  bubbles: false,
                  composed: true,
                  detail: {
                    originalEvent: event,
                    [eventType]: this
                  }
                };

                if (event.type === 'afterSetExtremes') {
                  if (event.min == null || event.max == null) {
                    return;
                  }
                }
                // Workaround for vaadin-charts-flow because of https://github.com/vaadin/flow/issues/3102
                if (event.type === 'selection') {
                  if (event.xAxis && event.xAxis[0]) {
                    customEvent.detail.xAxisMin = event.xAxis[0].min;
                    customEvent.detail.xAxisMax = event.xAxis[0].max;
                  }
                  if (event.yAxis && event.yAxis[0]) {
                    customEvent.detail.yAxisMin = event.yAxis[0].min;
                    customEvent.detail.yAxisMax = event.yAxis[0].max;
                  }
                }
                if (event.type === 'click') {
                  if (event.xAxis && event.xAxis[0]) {
                    customEvent.detail.xValue = event.xAxis[0].value;
                  }
                  if (event.yAxis && event.yAxis[0]) {
                    customEvent.detail.yValue = event.yAxis[0].value;
                  }
                }

                self.dispatchEvent(new CustomEvent(eventList[key], customEvent));

                if (event.type === 'legendItemClick' && chart['_visibilityTogglingDisabled']) {
                  return false;
                }
              };
            }
          }
        }

        __ensureObjectPath(object, path) {
          if (typeof path !== 'string') {
            return;
          }

          path = path.split('.');
          return path.reduce((obj, key) => {
            obj[key] = obj[key] || {};
            return obj[key];
          }, object);
        }

        __updateOrAddCredits(credits) {
          if (this.configuration.credits) {
            this.configuration.credits.update(credits);
          } else {
            this.configuration.addCredits(credits);
          }
        }

        __updateOrAddAxes(axes, isX) {
          if (!Array.isArray(axes)) {
            axes = [axes];
          }
          var confAxes = isX ? this.configuration.xAxis : this.configuration.yAxis;
          for (var i = 0; i < axes.length; i++) {
            var axis = axes[i];
            if (confAxes[i]) {
              confAxes[i].update(axis);
            } else {
              this.configuration.addAxis(axis, isX);
            }
          }
        }

        __updateOrAddSeries(series) {
          if (!Array.isArray(series)) {
            throw new Error('The type of jsonConfiguration.series should be Object[]');
          }
          for (var i = 0; i < series.length; i++) {
            var currentSeries = series[i];
            this.__updateOrAddSeriesInstance(currentSeries, i);
          }
        }

        __updateOrAddSeriesInstance(seriesOptions, position) {
          if (this.configuration.series[position]) {
            this.configuration.series[position].update(seriesOptions);
          } else {
            this.configuration.addSeries(seriesOptions);
          }
          return this.configuration.series[position];
        }

        __updateTitle(newValue) {
          if (!this.configuration) {
            return;
          }

          if (newValue && newValue.length > 0) {
            this.configuration.title.update({text: newValue});
          }
        }

        __updateSubtitle(newValue) {
          if (!this.configuration) {
            return;
          }

          if (newValue && newValue.length > 0) {
            if (!this.configuration.subtitle) {
              this.configuration.setSubtitle({text: newValue});
            } else {
              this.configuration.subtitle.update({text: newValue});
            }
          }
        }

        __isObject(item) {
          return (item && typeof item === 'object' && !Array.isArray(item));
        }

        __deepMerge(target, source) {
          if (this.__isObject(source) && this.__isObject(target)) {
            for (const key in source) {
              if (this.__isObject(source[key])) {
                if (!target[key]) {
                  Object.assign(target, {[key]: {}});
                }

                this.__deepMerge(target[key], source[key]);
              } else {
                Object.assign(target, {[key]: source[key]});
              }
            }
          }

          return target;
        }

        __callChartFunction(functionName) {
          if (this.configuration) {
            const functionToCall = this.configuration[functionName];
            const argumentsForCall = Array.prototype.splice.call(arguments, 1);
            if (functionToCall && typeof functionToCall === 'function') {
              functionToCall.apply(this.configuration, argumentsForCall);
            }
          }
        }

        __callSeriesFunction(functionName, seriesIndex) {
          if (this.configuration && this.configuration.series[seriesIndex]) {
            const series = this.configuration.series[seriesIndex];
            const functionToCall = series[functionName];
            const argumentsForCall = Array.prototype.splice.call(arguments, 2);
            if (functionToCall && typeof functionToCall === 'function') {
              functionToCall.apply(series, argumentsForCall);
            }
          }
        }

        __callAxisFunction(functionName, axisCategory, axisIndex) {
          /*
           * axisCategory:
           * 0 - xAxis
           * 1 - yAxis
           * 2 - zAxis
           * 3 - colorAxis
           */
          if (this.configuration) {
            let axes;
            switch (axisCategory) {
              case 0:
                axes = this.configuration.xAxis;
                break;
              case 1:
                axes = this.configuration.yAxis;
                break;
              case 2:
                axes = this.configuration.zAxis;
                break;
              case 3:
                axes = this.configuration.colorAxis;
                break;
            }
            if (axes && axes[axisIndex]) {
              const axis = axes[axisIndex];
              const functionToCall = axis[functionName];
              const argumentsForCall = Array.prototype.splice.call(arguments, 3);
              if (functionToCall && typeof functionToCall === 'function') {
                functionToCall.apply(axis, argumentsForCall);
              }
            }
          }
        }

        __callPointFunction(functionName, seriesIndex, pointIndex) {
          if (this.configuration && this.configuration.series[seriesIndex] && this.configuration.series[seriesIndex].data[pointIndex]) {
            const point = this.configuration.series[seriesIndex].data[pointIndex];
            const functionToCall = point[functionName];
            const argumentsForCall = Array.prototype.splice.call(arguments, 3);
            if (functionToCall && typeof functionToCall === 'function') {
              functionToCall.apply(point, argumentsForCall);
            }
          }
        }

        /**
         * Updates chart container and current chart style property depending on flex status
         */
        __updateStyles() {
          // Chrome returns default value if property is not set
          // check if flex is defined for chart, and different than default value
          const isFlex = this._copyStyleProperties.some(property =>
            getComputedStyle(this)[property] && getComputedStyle(this)[property] != '0 1 auto', this);

          // If chart element is a flexible item the chartContainer should be flex too
          if (isFlex) {
            this.$.chart.setAttribute('style', 'flex: 1; -webkit-flex: 1; -ms-flex: 1; ');
            var style = '';
            if (this.hasAttribute('style')) {
              style = this.getAttribute('style');
              if (style.charAt(style.length - 1) !== ';') {
                style += ';';
              }
            }
            style += 'display: -ms-flexbox; display: -webkit-flex; display: flex;';
            this.setAttribute('style', style);
          } else {
            this.$.chart.setAttribute('style', 'height:100%; width:100%;');
          }
        }
      }

      customElements.define(ChartElement.is, ChartElement);

      /**
       * @namespace Vaadin
       */
      window.Vaadin.ChartElement = ChartElement;
      if (window.Vaadin.runIfDevelopmentMode) {
        window.Vaadin.runIfDevelopmentMode('vaadin-license-checker', ChartElement);
      }

    }
  </script>
</dom-module>
