<!--
@license
Vaadin Charts

Copyright (C) 2015 Vaadin Ltd

This program is available under Commercial Vaadin Add-On License 3.0 (CVALv3).

See the file LICENSE.md distributed with this software for more information about licensing.

See <a href="https://vaadin.com/license/cval-3">the website</a> for the complete license.
-->
<link rel="import" href="../polymer/polymer.html">

<script>
    /**
     * Behavior that provides functions to load JSON config from the node hierarchical structure.
     */
    ConfigurationReaderBehavior = {

        /**
         * Elements that should be ignored when mapping
         **/
        _ignoredNodes: ["#text", "#comment", "data-series"],

        /**
         * List of words that will always be uppercased, instead of camel-cased
         **/
        _uppercaseWords: ["html"],

        /**
         * Elements that should be mapped in to an array, e.g. two x-axis elements would be mapped to the same
         * array
         **/
        _multivaluedNodes: ["xAxis", "yAxis", "plotBands", "plotLines", "background", "crosshairs", "stops", "levels", "pane", "items"],

        /**
         * Elements that contain an array of values, either as a comma-separated list or multiple elements
         **/
        _arrayNodes: ["categories", "stops", "margin", "center"],

        /**
         * Elements whose text content should be set as text property value
         **/
        _textContentNodes: ["subtitle", "title"],

        /**
         * Elements where the whole node is going to be used as value, their name is always valid
         **/
        _nodeValueAttributes: ["table"],

        _vaadinChartsPrefix: "vc-",

        /**
         * Check if the given attribute is valid as a Vaadin Charts configuration attribute
         **/
        _isVaadinChartsProperty: function (attName) {
            return attName != undefined &&
                    (attName.indexOf(this._vaadinChartsPrefix) === 0 || this._nodeValueAttributes.indexOf(attName) !== -1);
        },

        /**
         * Transform the given string to camel-case
         *
         * @param {string} str
         **/
        _toCamelCase: function (str, isElement) {
            var out = "";
            if (this._nodeValueAttributes.indexOf(str) !== -1) {
                out = str;
            } else {
                if (isElement) {
                    str = str.substring(this._vaadinChartsPrefix.length);
                }
                str.split("-").forEach(function (word, idx) {
                    var add = word.toLowerCase();
                    //first word always goes in lower case, the rest go with camelCase, except for _uppercaseWords
                    if (idx === 0 || this._uppercaseWords.indexOf(add) === -1) {
                        out += (idx === 0 ? add : add[0].toUpperCase() + add.slice(1));
                    } else {
                        out += word.toUpperCase();
                    }
                }, this);
            }
            return out;
        },

        /**
         * Read configuration from one element and its attributes
         *
         * @param {object} dest the chart configuration object
         * @param {node} parent the node that is parsed for configuration
         **/
        _loadFromNode: function (dest, node) {
            for (var i in node.attributes) {
                if (node.attributes.hasOwnProperty(i)) {
                    var attr = node.attributes[i].name;
                    if (attr !== undefined) {
                        var val = node.getAttribute(attr);
                        var res = this._parseAttribute(val);
                        dest[this._toCamelCase(attr)] = res;
                    }
                }
            }
            if (this._hasOnlyTextContent(node)) {
                dest.text = node.textContent;
            }
        },

        /**
         * Removes all empty text and comment nodes.
         **/
        _cleanNode: function (node) {
            for (var n = 0; n < node.childNodes.length; n++) {
                var child = node.childNodes[n];
                if (child.nodeType === 8 || (child.nodeType === 3 && !/\S/.test(child.nodeValue))) {
                    node.removeChild(child);
                    n--;
                } else if (child.nodeType === 1) {
                    this._cleanNode(child);
                }
            }
        },

        /**
         * Parse String attribute to most specific type possible.
         * Try JSON.parse, then eval if it's function, or return original value
         * @param {object} value to be set
         **/
        _parseAttribute: function (val) {
            var res;
            try {
                res = JSON.parse(val);
            } catch (e) {
                if (this._evalJavascript(val)) {
                    try {
                        res = eval('(' + val + ')');
                    } catch (e) {
                        res = val;
                    }
                } else {
                    res = val;
                }
            }
            return res;
        }
        ,

        _evalJavascript: function (val) {
            //if it's a function eval
            return val.indexOf('function') === 0;
        },


        /**
         * Return true if node has a single child with nodeType TEXT_NODE (3) and non-empty value.
         *
         * @param {node} the node to check
         **/
        _hasOnlyTextContent: function (node) {
            return node.hasChildNodes() && node.childNodes.length == 1 && node.childNodes[0].nodeType == 3 && node.textContent.trim() != "";
        },

        /**
         * Recursively load the configuration from the light-DOM elements.
         *
         * @param {object} dest the chart configuration object
         * @param {node} parent the node that contains the configuration elements
         **/
        _loadConfiguration: function (dest, parent) {
            for (var n = 0; n < parent.childNodes.length; n++) {
                var node = parent.childNodes[n];
                var name = node.nodeName.toLowerCase();
                if (this._isVaadinChartsProperty(name)) {
                    var camelName = this._toCamelCase(name, true);
                    if (this._ignoredNodes.indexOf(name) === -1) {
                        var result;

                        //read configuration into result
                        if (this._arrayNodes.indexOf(camelName) !== -1) {
                            result = [];
                            if (this._hasOnlyTextContent(node)) {
                                node.textContent.split(/\s*,\s*/).forEach(function (word) {
                                    result.push(this._parseAttribute(word));
                                }, this);
                            } else {
                                for (var i = 0; i < node.childNodes.length; i++) {
                                    var child = node.childNodes[i];
                                    result.push(this._parseAttribute(child.textContent));
                                }
                            }
                            result = result.length > 1 ? result : result[0];

                        } else if (this._nodeValueAttributes.indexOf(name) !== -1) {
                            result = node;
                        } else if (this._multivaluedNodes.indexOf(camelName) !== -1 || dest[camelName] === undefined) {
                            if (this._textContentNodes.indexOf(camelName) === -1 && this._hasOnlyTextContent(node)) {
                                result = node.textContent;
                            } else {
                                result = {};
                                this._loadFromNode(result, node);
                                this._loadConfiguration(result, node);
                            }
                        }

                        //put result in to the correct place
                        if (this._multivaluedNodes.indexOf(camelName) !== -1) {
                            if (dest[camelName] === undefined) {
                                dest[camelName] = [result];
                            } else {
                                dest[camelName].push(result);
                            }

                        } else if (dest[camelName] === undefined) {
                            dest[camelName] = result;
                        }
                    }
                }
            }
        },

        /**
         * Creates the missing objects to ensure the path exists
         **/
        _ensureObjectStructure: function (obj, path) {
            var parts = path.split(".");
            for (var i = 0; i < parts.length; i++) {
                if (!obj[parts[i]]) obj[parts[i]] = {};
                obj = obj[parts[i]];
            }
        }
    }
</script>
